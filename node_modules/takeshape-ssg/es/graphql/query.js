function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import { getLocation, parse, print, TypeInfo, visit, visitWithTypeInfo } from 'graphql';
import { addQueryVariables, wrapQuery } from './ast';

function getItemType(fieldType) {
  return fieldType.ofType || fieldType;
}

function getFields(type) {
  return type.getFields && type.getFields();
}

export function getFieldUsage(queryAst, schema, fileInfo) {
  const typeInfo = new TypeInfo(schema);
  const result = {};
  const visitor = {
    Field: {
      enter(node) {
        const type = getItemType(typeInfo.getFieldDef().type);
        const fields = getFields(type);
        const fieldInfo = result[type] || {};

        if (fields) {
          node.selectionSet.selections.forEach(selection => {
            const name = selection.name.value;
            const usage = fieldInfo[name] ? fieldInfo[name].usage : [];
            fieldInfo[name] = {
              type: fields[name].type,
              usage: usage.concat({
                file: fileInfo.name,
                location: getLocation({
                  body: fileInfo.body
                }, selection.loc.start)
              })
            };
          });
          result[type] = fieldInfo;
        }
      }

    }
  };
  visit(queryAst, visitWithTypeInfo(typeInfo, visitor));
  return result;
}

function addId(node) {
  const {
    selections
  } = node.selectionSet;

  if (!selections.find(selection => selection.name.value === '_id')) {
    selections.push({
      kind: 'Field',
      name: {
        kind: 'Name',
        value: '_id'
      },
      arguments: [],
      directives: []
    });
    return node;
  }
}

export function ensureIds(queryAst, schema) {
  const typeInfo = new TypeInfo(schema);
  const visitor = {
    Field: {
      enter(node) {
        const fieldDef = typeInfo.getFieldDef();

        if (fieldDef) {
          const type = getItemType(fieldDef.type);
          const fields = getFields(type);

          if (fields && fields._id) {
            return addId(node);
          }
        }
      }

    }
  };
  return visit(queryAst, visitWithTypeInfo(typeInfo, visitor));
}
const addLocaleVariable = addQueryVariables.bind(null, [{
  name: 'locale',
  type: 'String'
}]);
const wrapWithContext = wrapQuery.bind(null, 'withContext', [{
  name: 'locale',
  value: 'locale'
}]);
export function wrapWithLocaleContext(ast) {
  return wrapWithContext(addLocaleVariable(ast));
}

function unboxLocalizedResponse(res) {
  return _objectSpread({}, res, {
    data: res.data && res.data.withContext
  });
}

export function withQueryTransforms(connector, schema, {
  locale,
  usage
} = {}) {
  return (
    /*#__PURE__*/
    function () {
      var _ref = _asyncToGenerator(function* (gqlParams) {
        const variables = _objectSpread({}, gqlParams.variables);

        let queryAst = parse(gqlParams.query);

        if (usage) {
          queryAst = ensureIds(queryAst, schema);
        }

        if (locale) {
          variables.locale = variables.locale || locale;
          queryAst = wrapWithLocaleContext(queryAst);
        }

        const res = yield connector({
          query: print(queryAst),
          variables
        });
        return locale ? unboxLocalizedResponse(res) : res;
      });

      return function (_x) {
        return _ref.apply(this, arguments);
      };
    }()
  );
}