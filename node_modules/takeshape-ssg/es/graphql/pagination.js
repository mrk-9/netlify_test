function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _awaitAsyncGenerator(value) { return new _AwaitValue(value); }

function _wrapAsyncGenerator(fn) { return function () { return new _AsyncGenerator(fn.apply(this, arguments)); }; }

function _AsyncGenerator(gen) { var front, back; function send(key, arg) { return new Promise(function (resolve, reject) { var request = { key: key, arg: arg, resolve: resolve, reject: reject, next: null }; if (back) { back = back.next = request; } else { front = back = request; resume(key, arg); } }); } function resume(key, arg) { try { var result = gen[key](arg); var value = result.value; var wrappedAwait = value instanceof _AwaitValue; Promise.resolve(wrappedAwait ? value.wrapped : value).then(function (arg) { if (wrappedAwait) { resume("next", arg); return; } settle(result.done ? "return" : "normal", arg); }, function (err) { resume("throw", err); }); } catch (err) { settle("throw", err); } } function settle(type, value) { switch (type) { case "return": front.resolve({ value: value, done: true }); break; case "throw": front.reject(value); break; default: front.resolve({ value: value, done: false }); break; } front = front.next; if (front) { resume(front.key, front.arg); } else { back = null; } } this._invoke = send; if (typeof gen.return !== "function") { this.return = undefined; } }

if (typeof Symbol === "function" && Symbol.asyncIterator) { _AsyncGenerator.prototype[Symbol.asyncIterator] = function () { return this; }; }

_AsyncGenerator.prototype.next = function (arg) { return this._invoke("next", arg); };

_AsyncGenerator.prototype.throw = function (arg) { return this._invoke("throw", arg); };

_AsyncGenerator.prototype.return = function (arg) { return this._invoke("return", arg); };

function _AwaitValue(value) { this.wrapped = value; }

import '../async-iterator-polyfill';
import { createArgument, createVariableDefinition, createField, createSelectionSet } from './ast';
import keyBy from 'lodash/keyBy';
import { getIn, updateIn } from '../util';
import { parse, visit, print, visitWithTypeInfo, TypeInfo } from 'graphql';
import GraphQLError from '../errors/graphql-error';
import PaginationError from '../errors/pagination-error';
const paginationStrategies = [{
  type: 'cursor',
  fromName: 'after',
  sizeName: 'first',
  hasNextPath: ['pageInfo', 'hasNextPage'],
  cursorPath: ['pageInfo', 'endCursor'],
  itemsPath: ['items']
}, {
  type: 'offset',
  fromName: 'from',
  sizeName: 'size',
  totalPath: ['total'],
  itemsPath: ['items']
}, {
  type: 'offset',
  fromName: 'offset',
  sizeName: 'limit',
  totalPath: ['total'],
  itemsPath: ['items']
}];

function getPaginationStrategy(fieldDef) {
  if (fieldDef) {
    const {
      args
    } = fieldDef;

    if (args && args.length) {
      const keyedArgs = keyBy(args, 'name');
      return paginationStrategies.find(strategy => {
        const {
          fromName,
          sizeName
        } = strategy;
        return keyedArgs[fromName] && keyedArgs[sizeName];
      });
    }
  }
}

function getVariableName(path, name) {
  return path.concat([name]).join('_');
}

export function findPaginatedFields(ast, schema) {
  const typeInfo = new TypeInfo(schema);
  const result = [];
  const queryPath = [];
  const visitor = {
    Field: {
      enter(node, key, parent, path) {
        queryPath.push(node.alias ? node.alias.value : node.name.value);
        const fieldDef = typeInfo.getFieldDef();
        const strategy = getPaginationStrategy(fieldDef);

        if (strategy) {
          result.push({
            strategy,
            fromVarName: getVariableName(queryPath, strategy.fromName),
            sizeVarName: getVariableName(queryPath, strategy.sizeName),
            astPath: path.slice(),
            queryPath: queryPath.slice()
          }); // skip child nodes

          queryPath.pop();
          return false;
        }
      },

      leave() {
        queryPath.pop();
      }

    }
  };
  visit(ast, visitWithTypeInfo(typeInfo, visitor));
  return result;
}
export function removeNonPaginated(ast, paginatedFields) {
  const paths = Object.create(null);

  for (const field of paginatedFields) {
    paths[field.astPath.join('.')] = true;
  }

  const visitor = {
    Field: {
      enter(node, key, parent, path) {
        return paths[path.join('.')] ? false : null;
      }

    }
  };
  return visit(ast, visitor);
}
export function addPaginationVariables(ast, paginatedFields) {
  const variablesToReplace = Object.create(null);
  const variables = [];

  for (const paginatedField of paginatedFields) {
    const {
      fromVarName,
      sizeVarName,
      strategy
    } = paginatedField;
    const {
      sizeName,
      fromName
    } = strategy;
    updateIn(ast, paginatedField.astPath, field => {
      const newField = _objectSpread({}, field);

      newField.arguments = field.arguments.filter(arg => {
        const name = arg.name.value;

        if (name === sizeName || name === fromName) {
          if (arg.value.kind === 'Variable') {
            variablesToReplace[arg.value.name.value] = true;
          }

          return false;
        }

        return true;
      });
      newField.arguments.push(createArgument({
        name: fromName,
        value: fromVarName
      }));
      newField.arguments.push(createArgument({
        name: sizeName,
        value: sizeVarName
      }));
      variables.push({
        name: fromVarName,
        type: paginatedField.strategy.type === 'cursor' ? 'String' : 'Int'
      });
      variables.push({
        name: sizeVarName,
        type: 'Int'
      });
      return newField;
    });
  }

  const queryPath = paginatedFields[0].astPath.slice(0, 2);
  updateIn(ast, queryPath, query => {
    query.variableDefinitions = query.variableDefinitions.filter(def => !variablesToReplace[def.variable.name.value]).concat(variables.map(createVariableDefinition));
    return query;
  });
  return ast;
}
export function hasField(ast, queryPath) {
  let node = ast;

  for (const name of queryPath) {
    if (!node.selectionSet) {
      return false;
    }

    const field = node.selectionSet.selections.find(selection => selection.name.value === name);

    if (field) {
      node = field;
    } else {
      return false;
    }
  }

  return true;
}
export function ensureField(ast, queryPath) {
  let node = ast;

  for (const name of queryPath) {
    if (node.selectionSet) {
      let {
        selections
      } = node.selectionSet;
      const field = selections.find(selection => selection.name.value === name);

      if (field) {
        node = field;
      } else {
        selections = selections.concat([createField(name)]);
        node.selectionSet.selections = selections;
        node = selections[selections.length - 1];
      }
    } else {
      node.selectionSet = createSelectionSet([createField(name)]);
      node = node.selectionSet.selections[0];
    }
  }

  return ast;
}
export function ensurePaginationFields(ast, paginatedFields, source = '') {
  for (const paginatedField of paginatedFields) {
    const {
      strategy,
      astPath,
      queryPath
    } = paginatedField;
    const {
      type
    } = strategy;
    const field = getIn(ast, astPath);

    if (!hasField(field, strategy.itemsPath)) {
      const missingPath = queryPath.concat(strategy.itemsPath).join('.');
      throw new PaginationError(`Expected ${missingPath} to be specified: ${source}`);
    }

    if (type === 'cursor') {
      ensureField(field, strategy.hasNextPath);
      ensureField(field, strategy.cursorPath);
    } else {
      ensureField(field, strategy.totalPath);
    }
  }

  return ast;
}
export function isDone(queryArgs, queryData, paginatedField) {
  const {
    strategy,
    queryPath,
    fromVarName,
    sizeVarName
  } = paginatedField;
  const {
    hasNextPath,
    totalPath
  } = strategy;

  if (hasNextPath) {
    return !getIn(queryData, queryPath.concat(hasNextPath));
  }

  if (totalPath) {
    return queryArgs[fromVarName] + queryArgs[sizeVarName] >= getIn(queryData, queryPath.concat(totalPath));
  }

  throw Error('Invalid pagination strategy');
}

function incrementVariables(variables, data, paginatedField) {
  const {
    strategy,
    queryPath,
    fromVarName,
    sizeVarName
  } = paginatedField;
  const {
    cursorPath,
    type
  } = strategy;

  if (type === 'cursor') {
    variables[fromVarName] = getIn(data, queryPath.concat(cursorPath));
  } else {
    variables[fromVarName] += variables[sizeVarName];
  }
}

function handleErrors(res, source) {
  if (res.errors) {
    throw new GraphQLError(`An error occurred ${source}`, res.errors);
  }
}

export function getQueryIterator(_x, _x2, _x3) {
  return _getQueryIterator.apply(this, arguments);
}

function _getQueryIterator() {
  _getQueryIterator = _asyncToGenerator(function* (schema, query, connector, {
    variables,
    pageSize = 100,
    source,
    stats
  } = {}) {
    const queryAst = parse(query);
    const paginatedFields = findPaginatedFields(queryAst, schema);

    if (paginatedFields.length !== 1) {
      throw new PaginationError(`No paginated fields: ${source}`);
    }

    const astWithVars = addPaginationVariables(queryAst, paginatedFields);
    const astNormalized = ensurePaginationFields(astWithVars, paginatedFields, source);
    const queryWithVars = print(astNormalized);
    variables = _objectSpread({}, variables); // initialize pagination vars

    const paginatedField = paginatedFields[0];

    if (paginatedField.strategy.type === 'offset') {
      variables[paginatedField.fromVarName] = 0;
    }

    variables[paginatedField.sizeVarName] = pageSize;
    const itemsPath = paginatedField.queryPath.concat(paginatedField.strategy.itemsPath);
    const result = {};
    let first;
    const connectorContext = {
      source,
      stats,
      applyMigrations: false
    };

    if (paginatedField.strategy.type === 'offset') {
      const totalPath = paginatedField.queryPath.concat(paginatedField.strategy.totalPath);
      first = yield connector({
        query: queryWithVars,
        variables
      }, connectorContext);
      handleErrors(first, source);
      result.total = getIn(first.data, totalPath);
    }

    result.iterator =
    /*#__PURE__*/
    _wrapAsyncGenerator(function* () {
      while (true) {
        // eslint-disable-next-line no-await-in-loop
        const res = first || (yield _awaitAsyncGenerator(connector({
          query: queryWithVars,
          variables
        }, connectorContext)));

        if (first) {
          first = null;
        }

        handleErrors(res, source);

        for (const item of getIn(res.data, itemsPath)) {
          yield item;
        }

        if (isDone(variables, res.data, paginatedField)) {
          break;
        }

        incrementVariables(variables, res.data, paginatedField);
      }
    });
    return result;
  });
  return _getQueryIterator.apply(this, arguments);
}