function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _asyncIterator(iterable) { var method; if (typeof Symbol !== "undefined") { if (Symbol.asyncIterator) { method = iterable[Symbol.asyncIterator]; if (method != null) return method.call(iterable); } if (Symbol.iterator) { method = iterable[Symbol.iterator]; if (method != null) return method.call(iterable); } } throw new TypeError("Object is not async iterable"); }

import '../async-iterator-polyfill';
import BbPromise from 'bluebird';
import resolveContext, { resolveGraphQLConfig } from '../resolve-context';
import { getClientSchema, getQueryIterator, withQueryTransforms } from '../graphql';
import nunjucks from '../nunjucks';
import compressHtml from '../compress-html';
import { formatPath } from 'takeshape-routing';
import { joinPath } from '../paths';
import GraphQLError from '../errors/graphql-error';
import PaginationError from '../errors/pagination-error';
import mapValues from 'lodash/mapValues';
import flow from 'lodash/fp/flow';
import flatten from 'lodash/fp/flatten';
import partition from 'lodash/fp/partition';
import values from 'lodash/fp/values';
import { generateWarning, recordContentUsage } from '../stats';
import { createItemBuffer, createListPageBuffer } from './buffers';
import { combineContext, getItemContext, getListPageContext } from './context';

function handlePathWarnings(stats, warnings, route) {
  warnings.forEach(variable => {
    generateWarning(stats, 'renderPaginatedTemplate', `${route.path} variable ${variable} resolves to undefined.`);
  });
}

function handleMissingWarning(stats, route) {
  generateWarning(stats, 'renderPaginatedTemplate', `${route.path} item in ${route.paginate.property} is undefined`);
}

function resolveRoutesContext({
  routes,
  srcPath,
  connector,
  stats
}) {
  const handledRoutes = mapValues(routes, route => {
    const withContext = Object.assign({}, route, {
      context: resolveContext({
        contextConfig: route.context,
        srcPath,
        connector,
        route,
        stats
      })
    });
    return BbPromise.props(withContext);
  });
  return BbPromise.props(handledRoutes);
}

const pageSize = Number(process.env.TS_EXPERIMENTAL_PAGE_SIZE) || 100;

function getPaginatedData(_x, _x2, _x3) {
  return _getPaginatedData.apply(this, arguments);
}

function _getPaginatedData() {
  _getPaginatedData = _asyncToGenerator(function* (generateContext, paginate, context) {
    const {
      connector,
      srcPath,
      clientSchema,
      stats
    } = generateContext;

    if (paginate.data) {
      const config = yield resolveGraphQLConfig(paginate.data, srcPath);
      const res = yield getQueryIterator(clientSchema, config.query, connector, {
        pageSize,
        variables: config.variables,
        source: config.source,
        stats
      });
      return {
        iterable: res.iterator(),
        total: res.total
      };
    }

    if (paginate.property) {
      const itemsArray = context[paginate.property];

      if (itemsArray) {
        return {
          iterable: itemsArray,
          total: itemsArray.length
        };
      }
    }

    return null;
  });
  return _getPaginatedData.apply(this, arguments);
}

export function calculatePages(total, pageSize) {
  if (typeof total === 'number') {
    return Math.ceil(total / pageSize);
  }

  return undefined;
}
export function hasListPageConfig(paginate) {
  return paginate.pageSize && paginate.template && paginate.path;
}
export function hasItemPageConfig(route) {
  return route.path && route.template;
}
export function renderPaginatedTemplate(generateContext, getPaginatedData) {
  const {
    renderTemplate,
    stats,
    pathPrefix
  } = generateContext;
  return (
    /*#__PURE__*/
    function () {
      var _ref = _asyncToGenerator(function* (route, context) {
        const {
          paginate
        } = route;
        const shouldRenderItemPage = hasItemPageConfig(route);
        const shouldRenderListPage = hasListPageConfig(paginate);

        try {
          const paginatedData = yield getPaginatedData(generateContext, paginate, context);

          if (!paginatedData) {
            return [];
          }

          const totalPages = calculatePages(paginatedData.total, paginate.pageSize);
          const routeContext = {
            pathPrefix: generateContext.pathPrefix,
            totalPages,
            renderTemplate,
            route,
            context
          };
          let itemBuffer;

          if (shouldRenderItemPage) {
            itemBuffer = createItemBuffer(routeContext, getItemContext);
          }

          let listPageBuffer;

          if (shouldRenderListPage) {
            listPageBuffer = createListPageBuffer(routeContext, getListPageContext);
          }

          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;

          var _iteratorError;

          try {
            for (var _iterator = _asyncIterator(paginatedData.iterable), _step, _value; _step = yield _iterator.next(), _iteratorNormalCompletion = _step.done, _value = yield _step.value, !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {
              const item = _value;

              // eslint-disable-line semi
              if (!item) {
                handleMissingWarning(stats, route);
                continue;
              }

              if (shouldRenderItemPage) {
                const {
                  path,
                  warnings
                } = formatPath(route.path, item);
                const currentPath = joinPath(pathPrefix, path);

                if (warnings.length) {
                  handlePathWarnings(stats, warnings, route);
                  continue;
                } else {
                  recordContentUsage(stats, item, currentPath);
                }

                itemBuffer.push(item, currentPath);
              }

              if (shouldRenderListPage) {
                listPageBuffer.push(item);
              }
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return != null) {
                yield _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }

          const promises = [];

          if (shouldRenderItemPage) {
            promises.push(itemBuffer.done());
          }

          if (shouldRenderListPage) {
            promises.push(listPageBuffer.done());
          }

          return flatten((yield Promise.all(promises)));
        } catch (e) {
          if (e instanceof GraphQLError || e instanceof PaginationError) {
            throw e;
          }

          throw new Error(`Failed to render paginated route ${route.path}\n ${e.name}: ${e.message}`);
        }
      });

      return function (_x4, _x5) {
        return _ref.apply(this, arguments);
      };
    }()
  );
}

function renderTemplates(generateContext) {
  const {
    renderTemplate,
    config,
    pathPrefix
  } = generateContext;
  return routes => Promise.all(routes.map(route => {
    const context = combineContext(route, config);
    const path = joinPath(pathPrefix, route.path);
    return renderTemplate(path, route.template, context);
  }));
}

function renderPaginatedTemplates(generateContext) {
  const render = renderPaginatedTemplate(generateContext, getPaginatedData);
  return (
    /*#__PURE__*/
    function () {
      var _ref2 = _asyncToGenerator(function* (routes) {
        const promises = routes.map(route => render(route, combineContext(route, generateContext.config)));
        return flatten((yield Promise.all(promises)));
      });

      return function (_x6) {
        return _ref2.apply(this, arguments);
      };
    }()
  );
}

function generatePages(_x7, _x8) {
  return _generatePages.apply(this, arguments);
}

function _generatePages() {
  _generatePages = _asyncToGenerator(function* (config, generateContext) {
    const [context, routes] = yield Promise.all([resolveContext({
      contextConfig: config.context,
      srcPath: generateContext.srcPath,
      connector: generateContext.connector,
      stats: generateContext.stats
    }), resolveRoutesContext({
      routes: config.routes,
      srcPath: generateContext.srcPath,
      connector: generateContext.connector,
      stats: generateContext.stats
    })]);
    const resolvedConfig = {
      context: _objectSpread({}, context, {
        locale: config.locale
      }),
      routes,
      env: config.env
    };
    const [paginatedRoutes, singleRoutes] = flow(values, partition('paginate'))(resolvedConfig.routes);
    generateContext = _objectSpread({}, generateContext, {
      config: resolvedConfig
    });
    const singlePages = yield renderTemplates(generateContext)(singleRoutes);
    const paginatedPages = yield renderPaginatedTemplates(generateContext)(paginatedRoutes);
    return singlePages.concat(paginatedPages);
  });
  return _generatePages.apply(this, arguments);
}

export default function generate(_x9, _x10) {
  return _generate.apply(this, arguments);
}

function _generate() {
  _generate = _asyncToGenerator(function* (config, connector) {
    const srcPath = config.templatePath;
    const stats = {
      pagesGenerated: 0,
      warnings: []
    };

    if (config.usageStats) {
      stats.contentUsage = {};
    }

    const clientSchema = yield getClientSchema(connector);
    const generateContext = {
      pathPrefix: '',
      clientSchema,
      srcPath,
      stats
    };
    let pages;

    if (config.locales) {
      const localizedPages = yield BbPromise.map(Object.keys(config.locales), localeStr => {
        const locale = config.locales[localeStr];

        const localizedConfig = _objectSpread({}, config, {
          pathPrefix: locale.pathPrefix,
          locale: localeStr,
          dates: _objectSpread({}, config.dates, locale.dates),
          numbers: _objectSpread({}, config.numbers, locale.numbers)
        });

        return generatePages(localizedConfig, _objectSpread({}, generateContext, {
          renderTemplate: nunjucks(localizedConfig, stats),
          pathPrefix: locale.pathPrefix,
          connector: withQueryTransforms(connector, clientSchema, {
            locale: localeStr,
            usage: config.usageStats
          })
        }));
      });
      pages = flatten(localizedPages);
    } else {
      pages = yield generatePages(config, _objectSpread({}, generateContext, {
        renderTemplate: nunjucks(config, stats),
        connector: withQueryTransforms(connector, clientSchema, {
          usage: config.usageStats
        })
      }));
    }

    return {
      pages: compressHtml(config.htmlCompression)(pages),
      stats
    };
  });
  return _generate.apply(this, arguments);
}