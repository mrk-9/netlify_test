"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.calculatePages = calculatePages;
exports.hasListPageConfig = hasListPageConfig;
exports.hasItemPageConfig = hasItemPageConfig;
exports.renderPaginatedTemplate = renderPaginatedTemplate;
exports.default = generate;

require("../async-iterator-polyfill");

var _bluebird = _interopRequireDefault(require("bluebird"));

var _resolveContext = _interopRequireWildcard(require("../resolve-context"));

var _graphql = require("../graphql");

var _nunjucks = _interopRequireDefault(require("../nunjucks"));

var _compressHtml = _interopRequireDefault(require("../compress-html"));

var _takeshapeRouting = require("takeshape-routing");

var _paths = require("../paths");

var _graphqlError = _interopRequireDefault(require("../errors/graphql-error"));

var _paginationError = _interopRequireDefault(require("../errors/pagination-error"));

var _mapValues = _interopRequireDefault(require("lodash/mapValues"));

var _flow = _interopRequireDefault(require("lodash/fp/flow"));

var _flatten = _interopRequireDefault(require("lodash/fp/flatten"));

var _partition = _interopRequireDefault(require("lodash/fp/partition"));

var _values = _interopRequireDefault(require("lodash/fp/values"));

var _stats = require("../stats");

var _buffers = require("./buffers");

var _context = require("./context");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _asyncIterator(iterable) { var method; if (typeof Symbol !== "undefined") { if (Symbol.asyncIterator) { method = iterable[Symbol.asyncIterator]; if (method != null) return method.call(iterable); } if (Symbol.iterator) { method = iterable[Symbol.iterator]; if (method != null) return method.call(iterable); } } throw new TypeError("Object is not async iterable"); }

function handlePathWarnings(stats, warnings, route) {
  warnings.forEach(variable => {
    (0, _stats.generateWarning)(stats, 'renderPaginatedTemplate', `${route.path} variable ${variable} resolves to undefined.`);
  });
}

function handleMissingWarning(stats, route) {
  (0, _stats.generateWarning)(stats, 'renderPaginatedTemplate', `${route.path} item in ${route.paginate.property} is undefined`);
}

function resolveRoutesContext({
  routes,
  srcPath,
  connector,
  stats
}) {
  const handledRoutes = (0, _mapValues.default)(routes, route => {
    const withContext = Object.assign({}, route, {
      context: (0, _resolveContext.default)({
        contextConfig: route.context,
        srcPath,
        connector,
        route,
        stats
      })
    });
    return _bluebird.default.props(withContext);
  });
  return _bluebird.default.props(handledRoutes);
}

const pageSize = Number(process.env.TS_EXPERIMENTAL_PAGE_SIZE) || 100;

function getPaginatedData(_x, _x2, _x3) {
  return _getPaginatedData.apply(this, arguments);
}

function _getPaginatedData() {
  _getPaginatedData = _asyncToGenerator(function* (generateContext, paginate, context) {
    const {
      connector,
      srcPath,
      clientSchema,
      stats
    } = generateContext;

    if (paginate.data) {
      const config = yield (0, _resolveContext.resolveGraphQLConfig)(paginate.data, srcPath);
      const res = yield (0, _graphql.getQueryIterator)(clientSchema, config.query, connector, {
        pageSize,
        variables: config.variables,
        source: config.source,
        stats
      });
      return {
        iterable: res.iterator(),
        total: res.total
      };
    }

    if (paginate.property) {
      const itemsArray = context[paginate.property];

      if (itemsArray) {
        return {
          iterable: itemsArray,
          total: itemsArray.length
        };
      }
    }

    return null;
  });
  return _getPaginatedData.apply(this, arguments);
}

function calculatePages(total, pageSize) {
  if (typeof total === 'number') {
    return Math.ceil(total / pageSize);
  }

  return undefined;
}

function hasListPageConfig(paginate) {
  return paginate.pageSize && paginate.template && paginate.path;
}

function hasItemPageConfig(route) {
  return route.path && route.template;
}

function renderPaginatedTemplate(generateContext, getPaginatedData) {
  const {
    renderTemplate,
    stats,
    pathPrefix
  } = generateContext;
  return (
    /*#__PURE__*/
    function () {
      var _ref = _asyncToGenerator(function* (route, context) {
        const {
          paginate
        } = route;
        const shouldRenderItemPage = hasItemPageConfig(route);
        const shouldRenderListPage = hasListPageConfig(paginate);

        try {
          const paginatedData = yield getPaginatedData(generateContext, paginate, context);

          if (!paginatedData) {
            return [];
          }

          const totalPages = calculatePages(paginatedData.total, paginate.pageSize);
          const routeContext = {
            pathPrefix: generateContext.pathPrefix,
            totalPages,
            renderTemplate,
            route,
            context
          };
          let itemBuffer;

          if (shouldRenderItemPage) {
            itemBuffer = (0, _buffers.createItemBuffer)(routeContext, _context.getItemContext);
          }

          let listPageBuffer;

          if (shouldRenderListPage) {
            listPageBuffer = (0, _buffers.createListPageBuffer)(routeContext, _context.getListPageContext);
          }

          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;

          var _iteratorError;

          try {
            for (var _iterator = _asyncIterator(paginatedData.iterable), _step, _value; _step = yield _iterator.next(), _iteratorNormalCompletion = _step.done, _value = yield _step.value, !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {
              const item = _value;

              // eslint-disable-line semi
              if (!item) {
                handleMissingWarning(stats, route);
                continue;
              }

              if (shouldRenderItemPage) {
                const {
                  path,
                  warnings
                } = (0, _takeshapeRouting.formatPath)(route.path, item);
                const currentPath = (0, _paths.joinPath)(pathPrefix, path);

                if (warnings.length) {
                  handlePathWarnings(stats, warnings, route);
                  continue;
                } else {
                  (0, _stats.recordContentUsage)(stats, item, currentPath);
                }

                itemBuffer.push(item, currentPath);
              }

              if (shouldRenderListPage) {
                listPageBuffer.push(item);
              }
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return != null) {
                yield _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }

          const promises = [];

          if (shouldRenderItemPage) {
            promises.push(itemBuffer.done());
          }

          if (shouldRenderListPage) {
            promises.push(listPageBuffer.done());
          }

          return (0, _flatten.default)((yield Promise.all(promises)));
        } catch (e) {
          if (e instanceof _graphqlError.default || e instanceof _paginationError.default) {
            throw e;
          }

          throw new Error(`Failed to render paginated route ${route.path}\n ${e.name}: ${e.message}`);
        }
      });

      return function (_x4, _x5) {
        return _ref.apply(this, arguments);
      };
    }()
  );
}

function renderTemplates(generateContext) {
  const {
    renderTemplate,
    config,
    pathPrefix
  } = generateContext;
  return routes => Promise.all(routes.map(route => {
    const context = (0, _context.combineContext)(route, config);
    const path = (0, _paths.joinPath)(pathPrefix, route.path);
    return renderTemplate(path, route.template, context);
  }));
}

function renderPaginatedTemplates(generateContext) {
  const render = renderPaginatedTemplate(generateContext, getPaginatedData);
  return (
    /*#__PURE__*/
    function () {
      var _ref2 = _asyncToGenerator(function* (routes) {
        const promises = routes.map(route => render(route, (0, _context.combineContext)(route, generateContext.config)));
        return (0, _flatten.default)((yield Promise.all(promises)));
      });

      return function (_x6) {
        return _ref2.apply(this, arguments);
      };
    }()
  );
}

function generatePages(_x7, _x8) {
  return _generatePages.apply(this, arguments);
}

function _generatePages() {
  _generatePages = _asyncToGenerator(function* (config, generateContext) {
    const [context, routes] = yield Promise.all([(0, _resolveContext.default)({
      contextConfig: config.context,
      srcPath: generateContext.srcPath,
      connector: generateContext.connector,
      stats: generateContext.stats
    }), resolveRoutesContext({
      routes: config.routes,
      srcPath: generateContext.srcPath,
      connector: generateContext.connector,
      stats: generateContext.stats
    })]);
    const resolvedConfig = {
      context: _objectSpread({}, context, {
        locale: config.locale
      }),
      routes,
      env: config.env
    };
    const [paginatedRoutes, singleRoutes] = (0, _flow.default)(_values.default, (0, _partition.default)('paginate'))(resolvedConfig.routes);
    generateContext = _objectSpread({}, generateContext, {
      config: resolvedConfig
    });
    const singlePages = yield renderTemplates(generateContext)(singleRoutes);
    const paginatedPages = yield renderPaginatedTemplates(generateContext)(paginatedRoutes);
    return singlePages.concat(paginatedPages);
  });
  return _generatePages.apply(this, arguments);
}

function generate(_x9, _x10) {
  return _generate.apply(this, arguments);
}

function _generate() {
  _generate = _asyncToGenerator(function* (config, connector) {
    const srcPath = config.templatePath;
    const stats = {
      pagesGenerated: 0,
      warnings: []
    };

    if (config.usageStats) {
      stats.contentUsage = {};
    }

    const clientSchema = yield (0, _graphql.getClientSchema)(connector);
    const generateContext = {
      pathPrefix: '',
      clientSchema,
      srcPath,
      stats
    };
    let pages;

    if (config.locales) {
      const localizedPages = yield _bluebird.default.map(Object.keys(config.locales), localeStr => {
        const locale = config.locales[localeStr];

        const localizedConfig = _objectSpread({}, config, {
          pathPrefix: locale.pathPrefix,
          locale: localeStr,
          dates: _objectSpread({}, config.dates, locale.dates),
          numbers: _objectSpread({}, config.numbers, locale.numbers)
        });

        return generatePages(localizedConfig, _objectSpread({}, generateContext, {
          renderTemplate: (0, _nunjucks.default)(localizedConfig, stats),
          pathPrefix: locale.pathPrefix,
          connector: (0, _graphql.withQueryTransforms)(connector, clientSchema, {
            locale: localeStr,
            usage: config.usageStats
          })
        }));
      });
      pages = (0, _flatten.default)(localizedPages);
    } else {
      pages = yield generatePages(config, _objectSpread({}, generateContext, {
        renderTemplate: (0, _nunjucks.default)(config, stats),
        connector: (0, _graphql.withQueryTransforms)(connector, clientSchema, {
          usage: config.usageStats
        })
      }));
    }

    return {
      pages: (0, _compressHtml.default)(config.htmlCompression)(pages),
      stats
    };
  });
  return _generate.apply(this, arguments);
}