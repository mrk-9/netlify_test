"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.readPageBuffer = readPageBuffer;
exports.createItemBuffer = createItemBuffer;
exports.createListPageBuffer = createListPageBuffer;

var _paths = require("../paths");

function readPageBuffer(buffer, last) {
  const {
    length
  } = buffer;
  const offset = length === 1 || length < 3 && !last ? -1 : 0;
  return {
    previous: buffer[offset],
    current: buffer[1 + offset],
    next: buffer[2 + offset]
  };
}

function createItemBuffer(routeContext, getItemContext) {
  const {
    renderTemplate,
    route,
    context
  } = routeContext;
  const buffer = [];
  const result = [];

  const flush = last => {
    const items = readPageBuffer(buffer, last);
    const itemContext = getItemContext(route, context, items);
    result.push(renderTemplate(itemContext.currentPath, route.template, itemContext));
  };

  return {
    push(item, path) {
      buffer.push({
        item,
        path
      });

      if (buffer.length > 1) {
        flush(false);

        if (buffer.length > 2) {
          buffer.shift();
        }
      }
    },

    done() {
      if (buffer.length) {
        flush(true);
      }

      return Promise.all(result);
    }

  };
}

function createListPageBuffer(routeContext, getListPageContext) {
  const {
    renderTemplate,
    route,
    pathPrefix
  } = routeContext;
  const {
    paginate
  } = route;
  let buffer = [];
  const result = [];
  let page = 1;

  const flush = () => {
    const listContext = getListPageContext(buffer, page, routeContext);
    result.push(renderTemplate((0, _paths.joinPath)(pathPrefix, listContext.currentPath), paginate.template, listContext));
    page++;
    buffer = [];
  };

  return {
    push(item) {
      buffer.push(item);

      if (buffer.length === paginate.pageSize) {
        flush();
      }
    },

    done() {
      if (buffer.length) {
        flush();
      }

      return Promise.all(result);
    }

  };
}