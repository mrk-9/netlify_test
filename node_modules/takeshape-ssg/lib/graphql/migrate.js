"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.formatWarning = formatWarning;
exports.getMapResponse = getMapResponse;
exports.migrateListQueries = migrateListQueries;
exports.connectorWithMigrations = connectorWithMigrations;

var _language = require("graphql/language");

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function wrapListQuerySelection(selectionSet) {
  return {
    kind: 'SelectionSet',
    selections: [{
      kind: 'Field',
      name: {
        kind: 'Name',
        value: 'items'
      },
      arguments: [],
      directives: [],
      selectionSet
    }, {
      kind: 'Field',
      name: {
        kind: 'Name',
        value: 'total'
      },
      arguments: [],
      directives: []
    }]
  };
}

function isOldListQuery(selection) {
  const {
    name,
    selectionSet
  } = selection;
  return name.value.match(/^get.+List$/) && !selectionSet.selections.find(selection => selection.name.value === 'items' || selection.name.value === 'total');
}

function formatWarning(name, loc, queryStr, source = 'query.graphql') {
  const location = queryStr ? (0, _language.getLocation)({
    body: queryStr
  }, loc.start) : {
    line: 0,
    column: 0
  };
  return {
    message: `Using old format of ${name} Line ${location.line} Column ${location.column}`,
    location,
    source
  };
}

function getMapResponse(props) {
  return res => {
    // shallow clone res
    const newRes = _objectSpread({}, res);

    newRes.data = _objectSpread({}, res.data);

    for (const prop of props) {
      newRes.data[prop] = res.data[prop].items;
    }

    return newRes;
  };
}

function migrateListQueries(ast, queryStr, source) {
  let migrated = false;
  const migratedProps = [];
  const warnings = [];
  const queryDef = ast.definitions.find(definition => definition.operation === 'query');

  for (const selection of queryDef.selectionSet.selections) {
    if (isOldListQuery(selection)) {
      migratedProps.push(selection.alias ? selection.alias.value : selection.name.value);
      migrated = true;
      selection.selectionSet = wrapListQuerySelection(selection.selectionSet);
      warnings.push(formatWarning(selection.name.value, selection.loc, queryStr, source));
    }
  }

  return {
    ast,
    warnings,
    migrated,
    mapResponse: migrated ? getMapResponse(migratedProps) : null
  };
}

function connectorWithMigrations(connector) {
  return (
    /*#__PURE__*/
    function () {
      var _ref = _asyncToGenerator(function* (gqlParams, {
        stats,
        source,
        applyMigrations = true
      } = {}) {
        if (!applyMigrations) {
          return connector(gqlParams);
        }

        let {
          query
        } = gqlParams;
        const queryAst = (0, _language.parse)(query);
        const {
          migrated,
          warnings,
          ast,
          mapResponse
        } = migrateListQueries(queryAst, query, source);

        if (migrated) {
          query = (0, _language.print)(ast);
        }

        if (warnings && stats && stats.warnings) {
          stats.warnings = stats.warnings.concat(warnings);
        }

        let res = yield connector({
          query,
          variables: gqlParams.variables
        });

        if (migrated) {
          res = mapResponse(res);
        }

        return res;
      });

      return function (_x) {
        return _ref.apply(this, arguments);
      };
    }()
  );
}