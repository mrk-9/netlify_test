/**
 * string-find-heads-tails
 * Search for string pairs. A special case of string search algorithm.
 * Version: 3.16.1
 * Author: Roy Revelt, Codsen Ltd
 * License: MIT
 * Homepage: https://gitlab.com/codsen/codsen/tree/master/packages/string-find-heads-tails
 */

!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):(t=t||self).stringFindHeadsTails=e()}(this,(function(){"use strict";function t(e){return(t="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(e)}function e(t){return"string"==typeof t?t.length>0?[t]:[]:t}function r(t){if("string"==typeof t)return 0!==t.length&&(t.charCodeAt(0)>=55296&&t.charCodeAt(0)<=56319);if(void 0===t)return!1;throw new TypeError(`string-character-is-astral-surrogate/isHighSurrogate(): the input is not string but ${typeof t}`)}function n(t){if("string"==typeof t)return 0!==t.length&&(t.charCodeAt(0)>=56320&&t.charCodeAt(0)<=57343);if(void 0===t)return!1;throw new TypeError(`string-character-is-astral-surrogate/isLowSurrogate(): the input is not string but ${typeof t}`)}function i(t){return null!=t}function o(t){return"string"==typeof t&&(t.charCodeAt(0)>=55296&&t.charCodeAt(0)<=57343)}function a(t,e,o,a,s){const h="function"==typeof o?o():o;if(e>=t.length&&s&&"EOL"===h)return h;if(!(e<=t.length)){if(a.relaxedApi)return!1;throw new Error(`string-match-left-right/marchForward(): [THROW_ID_102] second argument, fromIndexInclusive is ${e} beyond the input string length, ${t.length}.`)}{let c=s?1:o.length;for(let s=e,h=t.length;s<h;s++){let e=t[s];if(r(t[s])&&n(t[s+1])&&(e=t[s]+t[s+1]),n(t[s])&&r(t[s-1])&&(e=t[s-1]+t[s]),a.trimBeforeMatching&&""===t[s].trim())continue;if(!a.i&&a.trimCharsBeforeMatching.includes(e)||a.i&&a.trimCharsBeforeMatching.map(t=>t.toLowerCase()).includes(e.toLowerCase())){2===e.length&&(s+=1);continue}let h=o[o.length-c];if(r(h)&&i(o[o.length-c+1])&&n(o[o.length-c+1])&&(h=o[o.length-c]+o[o.length-c+1]),!(!a.i&&e===h||a.i&&e.toLowerCase()===h.toLowerCase()))return!1;if(c-=e.length,c<1){let a=s-o.length+e.length;return a>=0&&n(t[a])&&i(t[a-1])&&r(t[a-1])&&(a-=1),a>=0?a:0}2===e.length&&r(t[s])&&(s+=1)}if(c>0)return!(!s||"EOL"!==h)}}function s(t,e,i,o,a){const s="function"==typeof i?i():i;if(e<0&&a&&"EOL"===s)return s;if(e>=t.length){if(o.relaxedApi)return!1;throw new Error(`string-match-left-right/marchBackward(): [THROW_ID_203] second argument, starting index, should not be beyond the last character of the input string! Currently the first argument's last character's index is ${t.length} but the second argument is beyond it:\n${JSON.stringify(e,null,4)}`)}let h=a?1:i.length;for(let s=e+1;s--;){if(o.trimBeforeMatching&&""===t[s].trim()){if(0===s&&a&&"EOL"===i)return!0;continue}let e=t[s];if(n(t[s])&&r(t[s-1])?e=t[s-1]+t[s]:r(t[s])&&n(t[s+1])&&(e=t[s]+t[s+1]),!o.i&&o.trimCharsBeforeMatching.includes(e)||o.i&&o.trimCharsBeforeMatching.map(t=>t.toLowerCase()).includes(e.toLowerCase())){if(2===e.length&&(s-=1),a&&"EOL"===i&&0===s)return!0;continue}let c=i[h-1];if(n(c)&&(c=`${i[h-2]}${i[h-1]}`,h-=1,s-=1),!(!o.i&&e===c||o.i&&e.toLowerCase()===c.toLowerCase()))return!1;if(h-=1,h<1)return s>=0?s:0}return h>0?!(!a||"EOL"!==s):void 0}function h(t,h,c,l){return function(t,h,c,l,f){if("object"==typeof f&&null!==f&&Object.prototype.hasOwnProperty.call(f,"trimBeforeMatching")&&"boolean"!=typeof f.trimBeforeMatching)throw new Error(`string-match-left-right/${t}(): [THROW_ID_09] opts.trimBeforeMatching should be boolean!${Array.isArray(f.trimBeforeMatching)?" Did you mean to use opts.trimCharsBeforeMatching?":""}`);const u=Object.assign({},{i:!1,trimBeforeMatching:!1,trimCharsBeforeMatching:[],relaxedApi:!1},f);let g,d,m,y;if(u.trimCharsBeforeMatching=e(u.trimCharsBeforeMatching),u.trimCharsBeforeMatching=u.trimCharsBeforeMatching.map(t=>"string"==typeof t?t:String(t)),u.trimCharsBeforeMatching.some((t,e)=>t.length>1&&!o(t)&&(g=e,d=t,!0)))throw new Error(`string-match-left-right/${t}(): [THROW_ID_07] the fourth argument, options object contains trimCharsBeforeMatching. It was meant to list the single characters but one of the entries at index ${g} is longer than 1 character, ${d.length} (equals to ${d}). Please split it into separate characters and put into array as separate elements.`);if("string"!=typeof h){if(u.relaxedApi)return!1;throw new Error(`string-match-left-right/${t}(): [THROW_ID_01] the first argument should be a string. Currently it's of a type: ${typeof h}, equal to:\n${JSON.stringify(h,null,4)}`)}if(0===h.length){if(u.relaxedApi)return!1;throw new Error(`string-match-left-right/${t}(): [THROW_ID_02] the first argument should be a non-empty string. Currently it's empty!`)}if(!(Number.isInteger(c)&&c>=0)){if(u.relaxedApi)return!1;throw new Error(`string-match-left-right/${t}(): [THROW_ID_03] the second argument should be a natural number. Currently it's of a type: ${typeof c}, equal to:\n${JSON.stringify(c,null,4)}`)}if("string"==typeof l)m=[l];else if(Array.isArray(l))m=l;else if(i(l)){if("function"!=typeof l)throw new Error(`string-match-left-right/${t}(): [THROW_ID_05] the third argument, whatToMatch, is neither string nor array of strings! It's ${typeof l}, equal to:\n${JSON.stringify(l,null,4)}`);m=[],m.push(l)}else m=l;if(i(f)&&"object"!=typeof f)throw new Error(`string-match-left-right/${t}(): [THROW_ID_06] the fourth argument, options object, should be a plain object. Currently it's of a type "${typeof f}", and equal to:\n${JSON.stringify(f,null,4)}`);if(!i(m)||!Array.isArray(m)||Array.isArray(m)&&!m.length||Array.isArray(m)&&1===m.length&&"string"==typeof m[0]&&0===m[0].trim().length){if("function"==typeof u.cb){let e,i=c;if("matchRight"===t&&r(h[c])&&n(h[c+1])&&(i+=1),"matchLeftIncl"!==t&&"matchRight"!==t||(i+=1),t.startsWith("matchLeft"))for(let t=i;t--;){if(n(h[t])&&r(h[t-1]))continue;let i=h[t];if(r(h[t])&&n(h[t+1])&&(i=h[t]+h[t+1]),(!u.trimBeforeMatching||u.trimBeforeMatching&&void 0!==i&&""!==i.trim())&&(0===u.trimCharsBeforeMatching.length||void 0!==i&&!u.trimCharsBeforeMatching.includes(i))){e=t;break}n(h[t-1])&&r(h[t-2])&&(t-=1)}else if(t.startsWith("matchRight"))for(let t=i;t<h.length;t++){let i=h[t];if(r(h[t])&&n(h[t+1])&&(i=h[t]+h[t+1]),(!u.trimBeforeMatching||u.trimBeforeMatching&&""!==i.trim())&&(0===u.trimCharsBeforeMatching.length||!u.trimCharsBeforeMatching.includes(i))){e=t;break}r(h[t])&&n(h[t+1])&&(t+=1)}if(void 0===e)return!1;let o=h[e];r(h[e])&&n(h[e+1])&&(o=h[e]+h[e+1]),n(h[e])&&r(h[e-1])&&(o=h[e-1]+h[e],e-=1);let a,s=e+1;return r(h[e])&&n(h[e+1])&&(s+=1),s&&s>0&&(a=h.slice(0,s)),t.startsWith("matchLeft")?u.cb(o,a,e):(e&&e>0&&(a=h.slice(e)),u.cb(o,a,e))}let e="";throw i(f)||(e=" More so, the whole options object, the fourth input argument, is missing!"),new Error(`string-match-left-right/${t}(): [THROW_ID_08] the third argument, "whatToMatch", was given as an empty string. This means, you intend to match purely by a callback. The callback was not set though, the opts key "cb" is not set!${e}`)}if(t.startsWith("matchLeft")){for(let e=0,a=m.length;e<a;e++){y="function"==typeof m[e];const a=m[e];let l,f,g="",d=c;"matchLeft"===t&&(o(h[e-1])&&o(h[e-2])?d-=2:d-=1);const p=s(h,d,a,u,y);if(p&&y&&"function"==typeof a&&"EOL"===a())return!(!a()||u.cb&&!u.cb(l,g,f))&&a();if(i(p)&&p>0&&(f=p-1,l=h[f],g=h.slice(0,p)),n(h[f])&&i(h[f-1])&&r(h[f-1])&&(f-=1,l=h[f-1]+h[f]),r(h[f])&&i(h[f+1])&&n(h[f+1])&&(l=h[f]+h[f+1],g=h.slice(0,f+2)),!1!==p&&(!u.cb||u.cb(l,g,f)))return a}return!1}for(let e=0,o=m.length;e<o;e++){y="function"==typeof m[e];const o=m[e];let s=c+("matchRight"===t?1:0);"matchRight"===t&&r(h[s-1])&&n(h[s])&&(s+=1);const l=a(h,s,o,u,y);if(l&&y&&"function"==typeof o&&"EOL"===o()){let t,e,r;return!(!o()||u.cb&&!u.cb(t,e,r))&&o()}let f,g,d;if(i(l)&&i(h[l+o.length-1])&&(f=l+o.length,g=h[f],r(h[f])&&n(h[f+1])&&(g=h[f]+h[f+1])),i(f)&&f>=0&&(d=h.slice(f)),!1!==l&&(!u.cb||u.cb(g,d,f)))return o}return!1}("matchRightIncl",t,h,c,l)}function c(t){return"string"==typeof t}return function(r,n,i,o){if(o&&(!(a=o)||"object"!==t(a)||Array.isArray(a)))throw new TypeError("string-find-heads-tails: [THROW_ID_01] the fourth input argument, an Optional Options Object, must be a plain object! Currently it's equal to: ".concat(o," (type: ").concat(t(o),")"));var a,s,l,f={fromIndex:0,throwWhenSomethingWrongIsDetected:!0,allowWholeValueToBeOnlyHeadsOrTails:!0,source:"string-find-heads-tails",matchHeadsAndTailsStrictlyInPairsByTheirOrder:!1,relaxedAPI:!1},u=Object.assign({},f,o);if("string"==typeof u.fromIndex&&/^\d*$/.test(u.fromIndex))u.fromIndex=Number(u.fromIndex);else if(!Number.isInteger(u.fromIndex)||u.fromIndex<0)throw new TypeError("".concat(u.source," [THROW_ID_18] the fourth input argument must be a natural number or zero! Currently it's: ").concat(u.fromIndex));if(!c(r)||0===r.length){if(u.relaxedAPI)return[];throw new TypeError("string-find-heads-tails: [THROW_ID_02] the first input argument, input string, must be a non-zero-length string! Currently it's: ".concat(t(r),", equal to: ").concat(r))}if("string"!=typeof n&&!Array.isArray(n)){if(u.relaxedAPI)return[];throw new TypeError("string-find-heads-tails: [THROW_ID_03] the second input argument, heads, must be either a string or an array of strings! Currently it's: ".concat(t(n),", equal to:\n").concat(JSON.stringify(n,null,4)))}if("string"==typeof n){if(0===n.length){if(u.relaxedAPI)return[];throw new TypeError("string-find-heads-tails: [THROW_ID_04] the second input argument, heads, must be a non-empty string! Currently it's empty.")}n=e(n)}else if(Array.isArray(n)){if(0===n.length){if(u.relaxedAPI)return[];throw new TypeError("string-find-heads-tails: [THROW_ID_05] the second input argument, heads, must be a non-empty array and contain at least one string! Currently it's empty.")}if(n.every((function(t,e){return s=t,l=e,c(t)}))){if(!n.every((function(t,e){return l=e,c(t)&&t.length>0&&""!==t.trim()}))){if(!u.relaxedAPI)throw new TypeError("string-find-heads-tails: [THROW_ID_07] the second input argument, heads, should not contain empty strings! For example, there's one detected at index ".concat(l," of heads array:\n").concat(JSON.stringify(n,null,4),"."));if(0===(n=n.filter((function(t){return c(t)&&t.length>0}))).length)return[]}}else{if(!u.relaxedAPI)throw new TypeError("string-find-heads-tails: [THROW_ID_06] the second input argument, heads, contains non-string elements! For example, element at ".concat(l,"th index is ").concat(t(s),", equal to:\n").concat(JSON.stringify(s,null,4),". Whole heads array looks like:\n").concat(JSON.stringify(n,null,4)));if(0===(n=n.filter((function(t){return c(t)&&t.length>0}))).length)return[]}}if(!c(i)&&!Array.isArray(i)){if(u.relaxedAPI)return[];throw new TypeError("string-find-heads-tails: [THROW_ID_08] the third input argument, tails, must be either a string or an array of strings! Currently it's: ".concat(t(i),", equal to:\n").concat(JSON.stringify(i,null,4)))}if(c(i)){if(0===i.length){if(u.relaxedAPI)return[];throw new TypeError("string-find-heads-tails: [THROW_ID_09] the third input argument, tails, must be a non-empty string! Currently it's empty.")}i=e(i)}else if(Array.isArray(i)){if(0===i.length){if(u.relaxedAPI)return[];throw new TypeError("string-find-heads-tails: [THROW_ID_10] the third input argument, tails, must be a non-empty array and contain at least one string! Currently it's empty.")}if(i.every((function(t,e){return s=t,l=e,c(t)}))){if(!i.every((function(t,e){return l=e,c(t)&&t.length>0&&""!==t.trim()}))){if(!u.relaxedAPI)throw new TypeError("string-find-heads-tails: [THROW_ID_12] the third input argument, tails, should not contain empty strings! For example, there's one detected at index ".concat(l,". Whole tails array is equal to:\n").concat(JSON.stringify(i,null,4)));if(0===(i=i.filter((function(t){return c(t)&&t.length>0}))).length)return[]}}else{if(!u.relaxedAPI)throw new TypeError("string-find-heads-tails: [THROW_ID_11] the third input argument, tails, contains non-string elements! For example, element at ".concat(l,"th index is ").concat(t(s),", equal to:\n").concat(JSON.stringify(s,null,4),". Whole tails array is equal to:\n").concat(JSON.stringify(i,null,4)));if(0===(i=i.filter((function(t){return c(t)&&t.length>0}))).length)return[]}}var g=u.source===f.source;if(u.throwWhenSomethingWrongIsDetected&&!u.allowWholeValueToBeOnlyHeadsOrTails){if(e(n).includes(r))throw new Error("".concat(u.source).concat(g?": [THROW_ID_16]":""," the whole input string can't be equal to ").concat(c(n)?"":"one of ","heads (").concat(r,")!"));if(e(i).includes(r))throw new Error("".concat(u.source).concat(g?": [THROW_ID_17]":""," the whole input string can't be equal to ").concat(c(i)?"":"one of ","tails (").concat(r,")!"))}for(var d,m=n.concat(i).map((function(t){return t.charAt(0)})).reduce((function(t,e){return e.charCodeAt(0)>t[1]?[t[0],e.charCodeAt(0)]:e.charCodeAt(0)<t[0]?[e.charCodeAt(0),t[1]]:t}),[n[0].charCodeAt(0),n[0].charCodeAt(0)]),y=[],p=!1,w={},b=!1,I=u.fromIndex,O=r.length;I<O;I++){var T=r[I].charCodeAt(0);if(T<=m[1]&&T>=m[0]){var A=h(r,I,n);if(A&&u.matchHeadsAndTailsStrictlyInPairsByTheirOrder)for(var _=n.length;_--;)if(n[_]===A){d=_;break}if(A){if(!p){(w={}).headsStartAt=I,w.headsEndAt=I+A.length,p=!0,I+=A.length-1,b&&(b=!1);continue}if(u.throwWhenSomethingWrongIsDetected)throw new TypeError("".concat(u.source).concat(g?": [THROW_ID_19]":"",' When processing "').concat(r,'", we found heads (').concat(r.slice(I,I+A.length),') starting at character with index number "').concat(I,'" and there was another set of heads before it! Generally speaking, there should be "heads-tails-heads-tails", not "heads-heads-tails"!\nWe\'re talking about the area of the code:\n\n\n--------------------------------------starts\n').concat(r.slice(Math.max(I-200,0),I),"\n      ","[".concat(33,"m-------\x3e[",39,"m")," ","[".concat(31,"m",r.slice(I,I+A.length),"[",39,"m")," [",33,"m","<-------","[",39,"m\n").concat(r.slice(I+A.length,Math.min(O,I+200)),"\n--------------------------------------ends\n\n\nTo turn off this error being thrown, set opts.throwWhenSomethingWrongIsDetected to Boolean false."))}var W=h(r,I,i);if(p&&W&&u.matchHeadsAndTailsStrictlyInPairsByTheirOrder&&void 0!==d&&void 0!==i[d]&&i[d]!==W){for(var C=void 0,x=i.length;x--;)if(i[x]===W){C=x;break}throw new TypeError("".concat(u.source).concat(g?": [THROW_ID_20]":"",' When processing "').concat(r,'", we had "opts.matchHeadsAndTailsStrictlyInPairsByTheirOrder" on. We found heads (').concat(n[d],") but the tails the followed it were not of the same index, ").concat(d," (").concat(i[d],") but ").concat(C," (").concat(W,")."))}if(W){if(p){w.tailsStartAt=I,w.tailsEndAt=I+W.length,y.push(w),w={},p=!1,I+=W.length-1;continue}u.throwWhenSomethingWrongIsDetected&&(b="".concat(u.source).concat(g?": [THROW_ID_21]":"",' When processing "').concat(r,'", we found tails (').concat(r.slice(I,I+W.length),') starting at character with index number "').concat(I,"\" but there were no heads preceding it. That's very naughty!"))}}if(u.throwWhenSomethingWrongIsDetected&&I===O-1){if(0!==Object.keys(w).length)throw new TypeError("".concat(u.source).concat(g?": [THROW_ID_22]":"",' When processing "').concat(r,"\", we reached the end of the string and yet didn't find any tails (").concat(JSON.stringify(i,null,4),") to match the last detected heads (").concat(r.slice(w.headsStartAt,w.headsEndAt),")!"));if(b)throw new Error(b)}}return y}}));
